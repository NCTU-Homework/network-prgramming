#!/usr/bin/python3

import socket
import sys
import json
import threading
from queue import Queue
from datetime import datetime
import traceback
from collections import deque

BUF_SIZE = 4096


def tcpSendMessage(sc: socket.socket, message: str):
    try:
        sc.sendall(message.encode('utf-8'))
    except Exception as e:
        raise IOError()


def tcpReceiveMessage(sc: socket.socket):
    msg = sc.recv(BUF_SIZE)
    if not msg:
        raise IOError()
    msg = msg.decode('utf-8')
    return msg


def udpReuqest(addr: str, port: int, message: str):
    udpSocket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    udpSocket.sendto(message.encode('utf-8'), (addr, port))
    data, _ = udpSocket.recvfrom(BUF_SIZE)
    data = data.decode('utf-8')
    udpSocket.close()
    return data


def hmmNow():
    time = datetime.now()
    return '%d:%02d' % (time.minute, time.second)


class ChatroomServer:

    flag = True
    msgQueue = Queue()
    userList = []
    chatQueue = deque()

    def __init__(self, port: int, owner: str):
        self.owner = owner

        self.ss = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.ss.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        self.ss.bind(('127.0.0.1', port))
        self.ss.listen()

        tProc = threading.Thread(target=self.procPlayground)
        tProc.daemon = True
        tProc.start()

        t = threading.Thread(target=self.run)
        t.daemon = True
        t.start()

    def broadcast(self, msg: str):
        for sc in self.userList:
            tcpSendMessage(sc, msg)

    def procPlayground(self):
        while self.flag:
            msg = self.msgQueue.get(True)
            msg['time'] = hmmNow()
            if len(self.chatQueue) == 3:
                self.chatQueue.popleft()
            self.chatQueue.append(msg)
            self.broadcast(json.dumps(msg))

    def userPlayground(self, sc: socket.socket):
        username = ''
        try:
            # Get username data
            msg = tcpReceiveMessage(sc)
            username = msg
        except IOError as e:
            pass

        try:
            # broadcast that new user joins
            self.broadcast(json.dumps({
                'username': 'sys',
                'message': '%s join us.' % (username),
                'time': hmmNow()
            }))

            # show history message
            for i in range(min(3, len(self.chatQueue))):
                tcpSendMessage(sc, json.dumps(self.chatQueue[i]))

            # add this user to socket list
            self.userList.append(sc)

            while self.flag:
                msg = tcpReceiveMessage(sc)
                if msg == '__EOF__' and username == self.owner:
                    self.broadcast(msg)
                    self.close()
                    break
                self.msgQueue.put({'username': username, 'message': msg})

        except IOError as e:
            pass

        self.userList.remove(sc)

    def run(self):
        try:
            while self.flag:
                sc, _ = self.ss.accept()
                t = threading.Thread(target=self.userPlayground, args=(sc, ))
                t.daemon = True
                t.start()
        except Exception as e:
            self.close()

    def close(self):
        if self.flag:
            self.flag = False
            self.ss.shutdown(socket.SHUT_RDWR)
            self.ss.close()


class ChatroomClient:

    flag = True
    socket = None
    owner = False
    isAttach = True
    chatQueue = deque()

    def printchat(self, msg):
        if self.isAttach:
            chatstr = '%s[%s]: %s' % (
                msg['username'], msg['time'], msg['message'])
            print(chatstr)

    def playground(self):
        try:
            while self.flag:
                msg = tcpReceiveMessage(self.socket)
                if msg == '__EOF__':
                    if self.flag:
                        self.printchat(
                            'sys[%s]: the chatroom is close.' % (hmmNow()))
                        self.close()
                    break

                msg = json.loads(msg)
                if self.owner:
                    if len(self.chatQueue) == 3:
                        self.chatQueue.popleft()
                    self.chatQueue.append(msg)
                self.printchat(msg)

        except IOError as e:
            self.close()
            pass

    def __init__(self, addr: str, port: int, username: str, isOwner=False):
        self.owner = isOwner

        self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.socket.connect((addr, port))
        t = threading.Thread(target=self.playground)
        t.daemon = True
        t.start()

        # send client username
        tcpSendMessage(self.socket, username)

    def showWelcome(self):
        print('*****************************')
        print('** Welcome to the chatroom **')
        print('*****************************')

    def showHistoryChat(self):
        for i in range(min(3, len(self.chatQueue))):
            self.printchat(self.chatQueue[i])

    def attach(self):
        self.isAttach = True
        self.showWelcome()
        if self.owner:
            self.showHistoryChat()

        try:
            while self.flag:
                line = input().strip()
                if len(line) == 0:
                    continue
                elif line == 'detach' and self.owner:
                    self.isAttach = False
                    return False
                elif line.strip() == 'leave-chatroom':
                    if self.owner:
                        tcpSendMessage(self.socket, '__EOF__')
                    self.close()
                    return True
                self.sendChat(line)
        except IOError as e:
            self.close()
            return True

    def sendChat(self, line: str):
        tcpSendMessage(self.socket, line)

    def close(self):
        if self.flag:
            self.flag = False
            self.socket.shutdown(socket.SHUT_RDWR)
            self.socket.close()


class Client:

    chatroomServer = None
    chatroomClient = None

    def createChatroom(self, port: int, username: str):
        assert(not self.chatroomServer)
        assert(not self.chatroomClient)
        print('Start to create chatroom...')

        self.chatroomServer = ChatroomServer(port, username)
        self.chatroomClient = ChatroomClient('127.0.0.1', port, username, True)
        self.attachChatroom()

    def joinChatroom(self, addr: str, port: int, username: str):
        assert(not self.chatroomClient)

        self.chatroomClient = ChatroomClient(addr, port, username)
        self.chatroomClient.attach()
        self.chatroomClient = None
        print('Welcome back to BBS.')

    def attachChatroom(self):
        assert(self.chatroomClient)
        foul = self.chatroomClient.attach()
        if foul:
            self.chatroomServer = None
            self.chatroomClient = None
            self.tcpSendRequest('close-chatroom')
        print('Welcome back to BBS.')

    def trivialTcp(self, line: str):
        res = self.tcpSendRequest(line)
        return res['message']

    def exit(self):
        if self.chatroomServer is not None:
            self.tcpSendRequest('close-chatroom')
        self.tcpSendRequest('logout')
        self.tcpSocket.close()
        exit()

    def consume(self, line: str):
        line = line.strip()
        if len(line) == 0:
            return

        command = line.split()[0]
        if command == 'exit':
            self.exit()
            return

        if command == 'list-chatroom':
            res = self.udpSendRequest(line)
        else:
            res = self.tcpSendRequest(line)

        if res['status'] != 200:
            print(res['message'])
            return

        if command == 'create-chatroom' or command == 'restart-chatroom':
            self.createChatroom(res['port'], res['username'])
        elif command == 'join-chatroom':
            self.joinChatroom(res['addr'], res['port'], res['username'])
        elif command == 'attach':
            self.attachChatroom()
        else:
            print(res['message'])

    def tcpSendRequest(self, message: str):
        tcpSendMessage(self.tcpSocket, message)
        msg = tcpReceiveMessage(self.tcpSocket)
        return json.loads(msg)

    def udpSendRequest(self, message: str):
        try:
            msg = udpReuqest(self.serverAddr, self.serverPort, message)
            return json.loads(msg)
        except Exception as e:
            print(e)
            raise e
        

    def run(self):
        self.tcpSocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.tcpSocket.connect((self.serverAddr, self.serverPort))
        print('********************************')
        print('** Welcome to the BBS server. **')
        print('********************************')
        try:
            while True:
                line = input('% ')
                self.consume(line)
        except IOError as e:
            if self.tcpSocket:
                self.tcpSocket.close()

    def __init__(self, addr: str, port: int):
        self.serverAddr = addr
        self.serverPort = port


def main():
    if len(sys.argv) != 3:
        print('Usage: client <address> <port>')
        exit(-1)

    addr = sys.argv[1]
    port = int(sys.argv[2])
    client = Client(addr, port)
    client.run()


if __name__ == '__main__':
    main()
