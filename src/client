#!/usr/bin/python3

import socket
import sys
import json
import threading
from queue import Queue
from datetime import datetime
import traceback

BUF_SIZE = 4096


def tcpSendMessage(sc: socket.socket, message: str):
    try:
        sc.sendall(message.encode('utf-8'))
    except Exception as e:
        raise IOError()


def tcpReceiveMessage(sc: socket.socket):
    msg = sc.recv(BUF_SIZE)
    if not msg:
        raise IOError()
    msg = msg.decode('utf-8')
    return msg


def hmmNow():
    time = datetime.now()
    return '%d:%02d' % (time.minute, time.second)


class ChatroomServer:

    flag = True
    msgQueue = Queue()
    userList = []

    def __init__(self, port: int, owner: str):
        self.owner = owner

        self.ss = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.ss.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        self.ss.bind(('127.0.0.1', port))
        self.ss.listen()

        tProc = threading.Thread(target=self.procPlayground)
        tProc.daemon = True
        tProc.start()

        t = threading.Thread(target=self.run)
        t.daemon = True
        t.start()

    def broadcast(self, msg: str):
        for sc in self.userList:
            tcpSendMessage(sc, msg)

    def procPlayground(self):
        while self.flag:
            msg = self.msgQueue.get(True)
            msg['time'] = hmmNow()
            self.broadcast(json.dumps(msg))

    def userPlayground(self, sc: socket.socket):
        username = ''
        try:
            # Get username data
            msg = tcpReceiveMessage(sc)
            username = msg
        except IOError as e:
            pass
        
        try:
            # broadcast that new user joins
            self.broadcast(json.dumps({
                'username': 'sys',
                'message': '%s join us.' % (username),
                'time': hmmNow()
            }))

            self.userList.append(sc)

            while self.flag:
                msg = tcpReceiveMessage(sc)
                if msg == '__EOF__' and username == self.owner:
                    self.broadcast(msg)
                    self.close()
                    break
                self.msgQueue.put({'username': username, 'message': msg})

        except IOError as e:
            pass
        
        self.userList.remove(sc)

    def run(self):
        try:
            while self.flag:
                sc, _ = self.ss.accept()
                t = threading.Thread(target=self.userPlayground, args=(sc, ))
                t.daemon = True
                t.start()
        except Exception as e:
            self.close()

    def close(self):
        if self.flag:
            self.flag = False
            self.ss.shutdown(socket.SHUT_RDWR)
            self.ss.close()

class ChatroomClient:

    flag = True
    socket = None
    owner = False

    def playground(self):
        try:
            while self.flag:
                msg = tcpReceiveMessage(self.socket)
                if msg == '__EOF__':
                    if self.flag:
                        print('sys[%s]: the chatroom is close.' % (hmmNow()))
                        self.close()
                    break
                msg = json.loads(msg)
                print('%s[%s]: %s' %
                        (msg['username'], msg['time'], msg['message']))
        except IOError as e:
            self.close()
            pass

    def __init__(self, addr: str, port: int, username: str, isOwner=False):
        self.owner = isOwner

        self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.socket.connect((addr, port))
        t = threading.Thread(target=self.playground)
        t.daemon = True
        t.start()

        # send client username
        tcpSendMessage(self.socket, username)

    def attach(self):
        print("""*****************************
** Welcome to the chatroom **
*****************************""")
        try:
            while self.flag:
                line = input().strip()
                if len(line) == 0:
                    continue
                elif line == 'detach':
                    return False
                elif line.strip() == 'leave-chatroom':
                    if self.owner:
                        tcpSendMessage(self.socket, '__EOF__')
                    self.close()
                    return True
                else:
                    self.sendChat(line)
        except IOError as e:
            self.close()
            return True
        

    def sendChat(self, line: str):
        tcpSendMessage(self.socket, line)

    def close(self):
        if self.flag:
            self.flag = False
            self.socket.shutdown(socket.SHUT_RDWR)
            self.socket.close()


class Client:

    chatroomServer = None
    chatroomClient = None

    def createChatroom(self, port: int, username: str):
        assert(not self.chatroomServer)
        assert(not self.chatroomClient)
        print('Start to create chatroom...')

        self.chatrommServer = ChatroomServer(port, username)
        self.chatroomClient = ChatroomClient('127.0.0.1', port, username, True)
        self.attachChatroom()

    def joinChatroom(self, addr: str, port: int, username: str):
        assert(not self.chatroomClient)

        self.chatroomClient = ChatroomClient(addr, port, username)
        self.chatroomClient.attach()
        self.chatroomClient = None
        print('Welcome back to BBS.')
    
    def attachChatroom(self):
        assert(self.chatroomClient)
        foul = self.chatroomClient.attach()
        if foul:
            self.chatrommServer = None
            self.chatroomClient = None
            self.tcpSendRequest('close-chatroom')
        print('Welcome back to BBS.')

    def trivialTcp(self, line: str):
        res = self.tcpSendRequest(line)
        return res['message']
    
    def exit(self):
        self.sc.close()
        exit()

    def consume(self, line: str):
        line = line.strip()
        if len(line) == 0:
            return

        command = line.split()[0]
        if command == 'exit':
            self.exit()
            return

        res = self.tcpSendRequest(line)
        if res['status'] != 200:
            print(res['message'])
            return

        if command == 'create-chatroom' or command == 'restart-chatroom':
            self.createChatroom(res['port'], res['username'])
        elif command == 'join-chatroom':
            self.joinChatroom(res['addr'], res['port'], res['username'])
        elif command == 'attach':
            self.attachChatroom()
        else:
            print(res['message'])

    def tcpSendRequest(self, message: str):
        tcpSendMessage(self.sc, message)
        msg = tcpReceiveMessage(self.sc)
        return json.loads(msg)

    def run(self):
        try:
            while True:
                line = input('% ')
                self.consume(line)
        except IOError as e:
            print(e)
            if self.sc:
                self.sc.close()

    def __init__(self, sc: socket.socket):
        self.sc = sc


def main():

    if len(sys.argv) != 3:
        print('Usage: client <address> <port>')
        exit(-1)

    addr = sys.argv[1]
    port = int(sys.argv[2])

    tcpSocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    tcpSocket.connect((addr, port))

    welcome = """********************************
** Welcome to the BBS server. **
********************************"""
    print(welcome)

    client = Client(tcpSocket)
    client.run()


if __name__ == '__main__':
    main()
